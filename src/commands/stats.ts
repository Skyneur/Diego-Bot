import { Command } from "@src/handlers/commands";
import { Client, ChatInputCommandInteraction, EmbedBuilder, ColorResolvable, MessageFlags, User } from "discord.js";
import { statsManager, GameType } from "@src/utils/stats/playerStats";
import { getEmoji } from "@src/constants/emojis";
import config from "@src/config";

const command = new Command<[Client, ChatInputCommandInteraction]>(
  "slash",
  "stats",
  "G√©rer les statistiques des joueurs",
  null,
  [
    {
      type: "String",
      name: "action",
      description: "Action √† effectuer",
      required: true,
      choices: [
        { name: "Afficher mes stats", value: "show" },
        { name: "Ajouter une victoire", value: "win" },
        { name: "Ajouter une d√©faite", value: "loss" },
        { name: "Voir le classement", value: "leaderboard" },
        { name: "R√©initialiser mes stats", value: "reset" }
      ]
    },
    {
      type: "String",
      name: "jeu",
      description: "Jeu concern√©",
      required: true,
      choices: [
        { name: "Valorant", value: "valorant" },
        { name: "League of Legends", value: "lol" }
      ]
    },
    {
      type: "User",
      name: "joueur",
      description: "Joueur (uniquement pour ajouter des stats √† un autre joueur)",
      required: false,
      choices: []
    }
  ],
  async (client, interaction) => {
    try {
      const action = interaction.options.getString("action") as string;
      const gameType = interaction.options.getString("jeu") as GameType;
      const targetUser = interaction.options.getUser("joueur") || interaction.user;
      const isAdmin = interaction.memberPermissions?.has("Administrator") || false;
      const isSelf = targetUser.id === interaction.user.id;

      if (!isSelf && !isAdmin && (action === "win" || action === "loss" || action === "reset")) {
        await interaction.reply({
          embeds: [
            new EmbedBuilder()
              .setTitle("‚ùå Acc√®s refus√©")
              .setDescription("### Permission insuffisante\n*Vous ne pouvez pas modifier les statistiques d'autres joueurs.*")
              .setColor("Red")
              .addFields({
                name: "üîí Restriction",
                 value: "Seuls les administrateurs peuvent modifier les statistiques des autres joueurs.",
                inline: false
              })
              .addFields({
                name: "üí° Alternative",
                value: "Vous pouvez uniquement modifier vos propres statistiques.",
                inline: false
              })
              .setFooter({ text: "Si vous pensez qu'il s'agit d'une erreur, contactez un administrateur" })
              .setTimestamp()
          ],
          flags: MessageFlags.Ephemeral
        });
        return;
      }
      
      const gameNames = {
        valorant: "Valorant",
        lol: "League of Legends"
      };
      
      const gameName = gameNames[gameType];
      
      switch (action) {
        case "show": {
          const playerStats = statsManager.getPlayerStats(targetUser.id);
          
          if (!playerStats || (playerStats.games[gameType].wins === 0 && playerStats.games[gameType].losses === 0)) {
            await interaction.reply({
              embeds: [
                new EmbedBuilder()
                  .setTitle(`${getEmoji('CHART')} Statistiques non disponibles`)
                  .setDescription(`### Aucune donn√©e trouv√©e\n*${targetUser.toString()} n'a pas encore de statistiques sur ${gameName}.*`)
                  .setColor(config.color as ColorResolvable)
                  .addFields({
                    name: `${getEmoji('GAME')} Comment commencer ?`,
                    value: `Pour ajouter des statistiques, utilisez les commandes suivantes :\n‚Ä¢ \/stats action:Ajouter une victoire jeu:${gameType}\n‚Ä¢ \/stats action:Ajouter une d√©faite jeu:${gameType}`,
                    inline: false
                  })
                  .setFooter({ text: "Les statistiques appara√Ætront ici d√®s que des parties seront enregistr√©es" })
                  .setTimestamp()
              ]
            });
            return;
          }
          
          const stats = playerStats.games[gameType];
          const totalGames = stats.wins + stats.losses;
          const winRate = totalGames > 0 ? Math.round((stats.wins / totalGames) * 100) : 0;
          
          const statsEmbed = new EmbedBuilder()
            .setTitle(`${getEmoji("NOTEPAD")} Statistiques ${gameName}`)
            .setDescription(`### Profil de ${targetUser.toString()}\n*Voici les statistiques pour ce joueur sur ${gameName}*`)
            .setColor(config.color as ColorResolvable)
            .setThumbnail(targetUser.displayAvatarURL())
            .addFields(
              { name: `${getEmoji("ROCKET")} Victoires`, value: `**${stats.wins}**`, inline: true },
              { name: `${getEmoji("CROSS")} D√©faites`, value: `**${stats.losses}**`, inline: true },
              { name: `${getEmoji("GLOBE")} Ratio V/D`, value: `**${winRate}%**`, inline: true },
              { name: `${getEmoji("GEAR")} Score ELO`, value: `**${stats.skillRating}**`, inline: true },
              { name: `${getEmoji("ROCKET")} Parties jou√©es`, value: `**${totalGames}**`, inline: true }
            )
            .setFooter({ text: `Joueur ID: ${targetUser.id} ‚Ä¢ Statistiques √† jour` })
            .setTimestamp();
          
          await interaction.reply({ embeds: [statsEmbed] });
          break;
        }
        
        case "win": {
          statsManager.addWin(targetUser.id, targetUser.tag, gameType);
          
          await interaction.reply({
            embeds: [
              new EmbedBuilder()
                .setTitle(`${getEmoji('CHECK2')} Victoire enregistr√©e`)
                .setDescription(`### F√©licitations ${targetUser.toString()} !\n*Une victoire a √©t√© ajout√©e √† votre palmar√®s sur ${gameName}.*`)
                .setColor("Green")
                .setTimestamp()
                .addFields(
                  { name: "`üíØ` Nouveau score", value: `**${statsManager.getPlayerStats(targetUser.id)?.games[gameType].skillRating || "N/A"}** (+25 points)`, inline: true },
                  { name: "`üìà` Total des victoires", value: `**${statsManager.getPlayerStats(targetUser.id)?.games[gameType].wins || "N/A"}**`, inline: true }
                )
                .setFooter({ text: "Utilisez /stats action:Afficher mes stats pour voir vos statistiques compl√®tes" })
            ]
          });
          break;
        }
        
        case "loss": {
          statsManager.addLoss(targetUser.id, targetUser.tag, gameType);
          
          await interaction.reply({
            embeds: [
              new EmbedBuilder()
                .setTitle(`${getEmoji('NOTEPAD')} D√©faite enregistr√©e`)
                .setDescription(`### Pas de chance ${targetUser.toString()} !\n*Une d√©faite a √©t√© ajout√©e √† votre historique sur ${gameName}.*`)
                .setColor("Red")
                .setTimestamp()
                .addFields(
                  { name: "`üíØ` Nouveau score", value: `**${statsManager.getPlayerStats(targetUser.id)?.games[gameType].skillRating || "N/A"}** (-20 points)`, inline: true },
                  { name: "`üìâ` Total des d√©faites", value: `**${statsManager.getPlayerStats(targetUser.id)?.games[gameType].losses || "N/A"}**`, inline: true }
                )
                .setFooter({ text: "La prochaine fois sera la bonne ! Continuez vos efforts." })
            ]
          });
          break;
        }
        
        case "leaderboard": {
          const leaderboard = statsManager.getLeaderboard(gameType);
          
          if (leaderboard.length === 0) {
            await interaction.reply({
              embeds: [
                new EmbedBuilder()
                  .setTitle(`\`üèÜ\` Classement ${gameName}`)
                  .setDescription("### Aucun joueur dans le classement\n*Soyez le premier √† ajouter des statistiques avec `/stats action:Ajouter une victoire`*")
                  .setColor(config.color as ColorResolvable)
                  .setTimestamp()
                  .setFooter({ text: "Les statistiques appara√Ætront ici d√®s que des parties seront enregistr√©es" })
              ]
            });
            return;
          }
          
          const leaderboardEmbed = new EmbedBuilder()
            .setTitle(`\`üèÜ\` Classement ${gameName}`)
            .setDescription(`### Top ${leaderboard.length} des joueurs\n*Voici les meilleurs joueurs actuels sur ${gameName}*`)
            .setColor(config.color as ColorResolvable)
            .setTimestamp();

          let topPlayersDesc = "";

          for (let i = 0; i < Math.min(3, leaderboard.length); i++) {
            const player = leaderboard[i];
            const stats = player.games[gameType];
            const totalGames = stats.wins + stats.losses;
            const winRate = totalGames > 0 ? Math.round((stats.wins / totalGames) * 100) : 0;
            
            const medals = ["ü•á", "ü•à", "ü•â"];
            
            topPlayersDesc += `${medals[i]} **${player.displayName}** - ${stats.skillRating} pts (WR: ${winRate}%)\n`;
          }
          
          if (topPlayersDesc) {
            leaderboardEmbed.addFields({
              name: "üî± Podium",
              value: topPlayersDesc,
              inline: false
            });
          }

          leaderboard.forEach((player, index) => {
            const stats = player.games[gameType];
            const totalGames = stats.wins + stats.losses;
            const winRate = totalGames > 0 ? Math.round((stats.wins / totalGames) * 100) : 0;

            let ratingEmoji = "‚ö™";
            if (winRate >= 55) ratingEmoji = "üü¢";
            else if (winRate >=35) ratingEmoji = "üü†";
            else ratingEmoji = "üî¥";
            
            leaderboardEmbed.addFields({
              name: `#${index + 1} ${player.displayName}`,
              value: `${ratingEmoji} ELO: **${stats.skillRating}** | V/D: **${stats.wins}**/**${stats.losses}** | Winrate: **${winRate}%**`,
              inline: false
            });
          });
          
          await interaction.reply({ embeds: [leaderboardEmbed] });
          break;
        }
        
        case "reset": {
          statsManager.resetPlayerStats(targetUser.id, gameType);
          
          await interaction.reply({
            embeds: [
              new EmbedBuilder()
                .setTitle("üóëÔ∏è Statistiques r√©initialis√©es")
                .setDescription(`### Nouveau d√©part pour ${targetUser.toString()}\n*Toutes les statistiques de ce joueur pour ${gameName} ont √©t√© r√©initialis√©es.*`)
                .setColor("Orange")
                .addFields(
                  { name: "üí´ Score r√©initialis√©", value: "**1000**", inline: true },
                  { name: "üßπ Donn√©es effac√©es", value: "Victoires et d√©faites", inline: true }
                )
                .setFooter({ text: "Cette action ne peut pas √™tre annul√©e" })
                .setTimestamp()
            ],
            flags: MessageFlags.Ephemeral
          });
          break;
        }
      }
    } catch (error) {
      console.error("Erreur dans la commande stats:", error);
      
      if (interaction.isRepliable() && !interaction.replied) {
        await interaction.reply({
          embeds: [
            new EmbedBuilder()
              .setTitle(`${getEmoji('CROSS2')} Erreur`)
              .setDescription("### Une erreur est survenue\n*Le syst√®me a rencontr√© un probl√®me lors de l'ex√©cution de cette commande.*")
              .setColor("Red")
              .addFields({ 
                name: "üìã D√©tails techniques", 
                value: `\`\`\`${error}\`\`\``,
                inline: false 
              })
              .addFields({
                name: "üîÑ Solution",
                value: "Veuillez r√©essayer dans quelques instants ou contacter un administrateur si le probl√®me persiste.",
                inline: false
              })
              .setFooter({ text: "Cette erreur a √©t√© enregistr√©e pour analyse" })
              .setTimestamp()
          ],
          flags: MessageFlags.Ephemeral
        });
      }
    }
  }
);

export default command;